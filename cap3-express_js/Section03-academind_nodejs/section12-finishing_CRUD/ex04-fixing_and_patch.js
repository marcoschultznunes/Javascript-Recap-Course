/* 
    Image deletion was not working because returning inside the unlink function does not work, 
as it is an anonymous function. */

/* image_function.js */
const path = require('path')
const fs = require('fs')

const deleteImage = (imageUrl) => {
    const imagePath = path.join(__dirname, '..', '..', imageUrl)
    
    let result = true

    fs.unlink(imagePath, (err) => {
        result = true
    })

    return result // return on the external function
}

exports.deleteImage = deleteImage


/* We added a nodemon.json file with delay of 1 second, so that the process is killed more often
upon restarting 

{ 
    "delay": 1000,
    "watch": ["app"],
    "ext": "js, json, ts, proto"
}

*/


/* 
    Multer uploads before the controller function is called. This meant that we always uploaded
an image, even when an error was thrown. We still do, but, in our POST and PATCH routes, we've
now called the deleteImage method whenever an error occurs, so that the image is instantly 
deleted when it arrives, and the user must be logged in.
*/

/* post_controller PATCH */
exports.patchPost = (req, res, next) => {
    const id = req.params.id

    const errors = validationResult(req)
    if(!errors.isEmpty()){
        const err = new Error('Validation failed. Entered data is incorrect!')
        err.statusCode = 422
        err.errors = errors.array()

        if(req.file){
            deleteImage(req.file.path) // Here too, because the catch does not cover it
        }
        throw err
    }

    PostModel.findById(id)
        .then(post => {
            if(!post){
                const err = new Error('No post found with given ID.')
                err.statusCode = 404
                throw err
            }

            let imageUrl = false

            let = success = true
            if(req.file){
                imageUrl = req.file.path
                success = deleteImage(post.imageUrl)
            }
            if(!success){
                const err = new Error('An error has occurred while deleting post image. Please, try again. If failure persists, contact support.')
                throw err
            }

            const {title, content, creator} = req.body 

            return PostModel.findOneAndUpdate({_id: id}, {
                ...req.body,
                imageUrl: imageUrl || post.imageUrl,
            })
        })
        .then(() => {
            return res.status(200).json({
                message: 'Successfully updated post.'
            })
        })
        .catch(err => {
            if(!err.statusCode){
                err.statusCode = 500
            }

            console.log('OI')

            /* Does this add a security flaw? No, because the file path generated by multer
            will add the timestamp at the beginning, guaranteeing it to be different from 
            any other file. */
            if(req.file){
                deleteImage(req.file.path) // Important, otherwise multer still uploads
            }

            return next(err)
        })
}

/* We've also added it to our POST route. This is probably not the best approach, the best 
approach might be to use another library instead of multer. */
